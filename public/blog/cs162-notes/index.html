<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"/>
        <meta content="width=device-width, initial-scale=1" name="viewport"/>

        
        
        

        

        

        

        
        
        

        <title>jalsol&#x27;s insight notes on CS162</title>
        
        <meta name="title" content="jalsol&#x27;s insight notes on CS162">
        
        
        <meta name="generator" content="Zola v0.16.1">

        <meta property="og:type" content="website">
        <meta property="og:url" content="https://jalsol.github.io/blog/cs162-notes/">
        <meta property="og:site_name" content="">
        <meta property="og:title" content="jalsol&#x27;s insight notes on CS162">
        
        

        
        
        
        <link rel="canonical" href="https://jalsol.github.io/blog/cs162-notes/">
        
        <script type="application/ld+json">
            {
                
                "url":"https://jalsol.github.io/blog/cs162-notes/",
                "@type":"WebSite",
                "headline":"jalsol's insight notes on CS162",
                "name":"jalsol's insight notes on CS162",
                
                "@context":"https://schema.org"
            }
        </script>
        
        
        
        <link rel="stylesheet" href="https://jalsol.github.io/style.css"/>
        
    </head>
    <body theme="auto">
        <div class="w">
            <header>
                
                <nav>
                    
                    <a href="/" >~home</a>
                    
                    <a href="/blog" >*blogs</a>
                    
                </nav>
                
                
<p class="post-meta"><time datetime="2023-03-18">2023-03-18</time></p>
<h1>jalsol&#x27;s insight notes on CS162</h1>

            </header>
            <main class="page-content" aria-label="Content">
                


Table of contents
<ul>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#preface">Preface</a>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#nullptr-null-0">nullptr&#x2F;NULL&#x2F;0</a>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#use-before-initialization-after-free">Use before initialization&#x2F;after free</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#before-initialization">Before initialization</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#after-free">After free</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#int-a-n">int a[n];</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#explanation">Explanation</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#history">History</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#reinterpret-cast">Reinterpret-cast</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#pointer-disguise">Pointer disguise</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#dereferencing-the-disguised-pointer">Dereferencing the disguised pointer</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#what-else">What else?</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#int-a-b-c">int* a, b, c;</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#what-the-fuck">What the fuck?</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#coding-convention-for-pointer-annotation">Coding convention for pointer annotation</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#why">Why?</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#size-as-a-function-parameter">Size as a function parameter?</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#dr-tien-was-wrong">Dr. Tien was &quot;wrong&quot;</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#or-was-he">Or, was he?</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#hungarian-notation">Hungarian notation</a>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#showing-off">&quot;Showing off&quot;</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#constructor">Constructor</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#data-0xdeafbeaf">data = 0xdeafbeaf;</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#assignment-in-constructors">Assignment in constructors???</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#conclusion">Conclusion</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#the-arrow-operator">-&gt; (The arrow operator)</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#what-is-it">What is it?</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#the-white-spaces-around-it">The white spaces around it</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#char-x-alice">char* x = &quot;Alice&quot;;</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#question">Question</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#the-unexpected-answer">The unexpected answer</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#analysis">Analysis</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#program-crash">Program crash</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#the-result-after-fixing-the-crash">The result after fixing the crash</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#printf-c-c-ppp-ppp">printf(&quot;%c %c &quot;, *++ppp, --*ppp);</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#question-1">Question</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#analysis-1">Analysis</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#const-int-p-vs-int-const-p">const int* p vs int* const p</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#east-const-vs-west-const">East-const vs West-const</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#what-s-so-cool-about-east-const">What&#x27;s so cool about east-const?</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#debunk-the-brain-fucker">Debunk the brain fucker</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#int-pop-exit-code-and-error-handling">int pop(), exit code, and error handling</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#he-do-a-little-trolling">he do a little trolling</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#why-int-why-int-main">Why int? Why int main()?</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#exceptions">Exceptions</a>
                    </li>
                
            </ul>
        
    </li>

    <li>
        <a href="https://jalsol.github.io/blog/cs162-notes/#return-value-or-function-argument">Return value or Function argument?</a>
        
            <ul>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#why-function-argument">Why function argument?</a>
                    </li>
                
                    <li>
                        <a href="https://jalsol.github.io/blog/cs162-notes/#why-return-value">Why return value?</a>
                    </li>
                
            </ul>
        
    </li>

</ul>


<p>(&quot;C++ Weekly with Jalsol Turner&quot;)</p>
<p>In this course, you'll be learning about pointers and manual memory management, which has always been a key feature of C/C++. It assumes you are capable of doing things (<em>unfortunately, you probably aren't, and I'm not that much better either</em>).</p>
<blockquote>
<p>If you are from the &quot;High Quality&quot; program of HCMUS and your lecturer of CSC10002 happens to be Dr. Dinh Ba Tien, then you can read this as well (both courses are exactly the same, from the theory classes to the lab sessions).</p>
</blockquote>
<blockquote>
<p>If your lecturer happens to be someone else (or perhaps you don't take any CS class), you can still read this, but remember that this note is based on my experience with CS162.</p>
</blockquote>
<p>I am open to all suggestions! If there is something you would like to add/correct (that is related to the course), please <a rel="noopener" target="_blank" href="https://www.facebook.com/jalsol.page">message</a>/<a href="mailto:jalsol@protonmail.com">email</a> me. Thank you so much!</p>
<hr />
<h2 id="preface">Preface</h2>
<p>I assume you have read my notes on CS161, and you know how I write my content.</p>
<blockquote>
<p>Once again, if you see vulgar language from me on this blog, it's <strong>most likely <del>satire</del> a safety warning and there's no intention to hurt anyone</strong>. Don't take it personally.</p>
</blockquote>
<blockquote>
<p><strong>I will also assume that you know your lessons from the lectures.</strong> I will not be discussing basic concepts. This is more like an expansion to provide deeper knowledge. <strong>Thus, this blog can be useless for reviewing your lessons.</strong> For review, check out <a rel="noopener" target="_blank" href="https://hc22apcs2.github.io/docs/CS162/">Study with 22APCS2</a>.</p>
</blockquote>
<p><img src="https://jalsol.github.io/blog/cs162-notes/preface.png" alt="" loading="lazy" decoding="async" /></p>
<blockquote>
<p>&gt;I have renamed it to &quot;insight notes&quot;<br/>
&gt;and made a point that this note is not for lessons review<br/>
&gt;and I'll assume that you study properly<br/></p>
</blockquote>
<hr />
<h2 id="nullptr-null-0"><code>nullptr/NULL/0</code></h2>
<p>The null pointer is a special pointer. It points to the memory block with the address <code>0</code>. Usually, <strong>this is used to tell that this pointer does not point to anything.</strong></p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> ptr</span><span style="color:#7c7f93;">;
</span><span>ptr </span><span style="color:#179299;">= </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Standard C++ (since C++11)
</span><span>ptr </span><span style="color:#179299;">= </span><span style="color:#d20f39;">NULL</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Standard C/Old C++ (before C++11)
</span><span>ptr </span><span style="color:#179299;">= </span><span style="color:#fe640b;">0</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Exactly the same as ptr = NULL but it is not recommended
</span><span>
</span><span style="color:#8839ef;">if </span><span style="color:#7c7f93;">(</span><span>ptr </span><span style="color:#179299;">== </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">) {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// pointer does not point to anything
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>In fact, some functions return <code>nullptr</code> if they report a failure related to pointers. Usually, they are functions adopted from C (modern C++ functions throw exceptions instead).</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;cstdio&gt; </span><span style="font-style:italic;color:#9ca0b0;">// std::FILE, std::fopen 
</span><span>
</span><span style="font-style:italic;color:#9ca0b0;">// the C way to open a file
</span><span>std</span><span style="color:#179299;">::</span><span>FILE</span><span style="color:#179299;">*</span><span> fp </span><span style="color:#179299;">= </span><span>std</span><span style="color:#179299;">::</span><span style="font-style:italic;color:#1e66f5;">fopen</span><span style="color:#7c7f93;">(</span><span style="color:#40a02b;">&quot;some_file&quot;</span><span style="color:#7c7f93;">, </span><span style="color:#40a02b;">&quot;w&quot;</span><span style="color:#7c7f93;">);
</span><span>
</span><span style="color:#8839ef;">if </span><span style="color:#7c7f93;">(</span><span>fp </span><span style="color:#179299;">== </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">) {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// can&#39;t open the file
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p><code>NULL</code> is an old thing from C. <code>NULL</code> is implementation-defined, which means that how it's defined depends on the compiler. From the <a rel="noopener" target="_blank" href="https://en.cppreference.com/w/c/types/NULL">C documentation</a>, <code>NULL</code> may be:</p>
<ul>
<li>an integer <code>0</code></li>
<li>a pointer <code>(void*) 0</code></li>
<li><code>nullptr</code> (since C23, to comply with the use of the modern null pointer)</li>
</ul>
<blockquote>
<p>There are many reasons why <code>nullptr</code> should always be preferred. Our intention is clearer to the compiler. <code>nullptr</code> can be converted to any pointer type but not integral types, which avoids ambiguity, compared to <code>NULL</code>.</p>
</blockquote>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">void </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="font-style:italic;color:#e64553;">int</span><span style="color:#7c7f93;">) {
</span><span>  std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&quot;f(int)&quot;</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">void </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">void</span><span style="color:#179299;">* </span><span style="font-style:italic;color:#9ca0b0;">/* accepts any pointer */</span><span style="color:#7c7f93;">) {
</span><span>  std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&quot;f(void*)&quot;</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>  </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">); </span><span style="font-style:italic;color:#9ca0b0;">// will call f(void*)
</span><span>
</span><span>  </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#d20f39;">NULL</span><span style="color:#7c7f93;">); </span><span style="font-style:italic;color:#9ca0b0;">// NULL can also be implicitly cast to an int,
</span><span>           </span><span style="font-style:italic;color:#9ca0b0;">// it won&#39;t know whether to act as an int or a pointer,
</span><span>           </span><span style="font-style:italic;color:#9ca0b0;">// causing a compile error because of ambiguity
</span><span style="color:#7c7f93;">}
</span></code></pre>
<hr />
<h2 id="use-before-initialization-after-free">Use before initialization/after free</h2>
<p>In the second CS162 lecture of the first week, I asked Dr. Tien a question with 2 scenarios. I am a little bit disappointed because he didn't provide us with a way to avoid bugs in those scenarios, which was my intention of asking in the first place.</p>
<h3 id="before-initialization">Before initialization</h3>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> p</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// no initialization
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; *</span><span>p </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p><strong>This is dangerous.</strong></p>
<p>A pointer is still a variable. Since there is no initialization, a random/garbage value is assigned. You don't know which part of the memory you are working with. <em>It is the same as fucking without looking and you insert into the wrong hole.</em></p>
<blockquote>
<p>Unless you have a reason to declare a pointer without pointing it to anything, you should not do it. You may assign <code>nullptr</code> to it just in case.</p>
</blockquote>
<h3 id="after-free">After free</h3>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> p </span><span style="color:#179299;">= </span><span style="color:#8839ef;">new int</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ... use p
</span><span>    </span><span style="color:#8839ef;">delete</span><span> p</span><span style="color:#7c7f93;">;
</span><span>
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; *</span><span>p </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// vulnerability
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p><strong>This is also dangerous. But a lot more dangerous. This is an actual vulnerability that got exploited in the past.</strong></p>
<blockquote>
<p><em>A lot of systems got fucked in the ass because of it. A whole lot of money went down the drain because some stupid and careless programmers forgot this could happen.</em></p>
</blockquote>
<p>The object that <code>p</code> points to is now gone. <strong>However, <code>p</code> still points to that same block of memory where the object used to live, even after freeing.</strong></p>
<p>If you are bloody lucky, nothing wrong will happen. If you are not (<em>which is usually the case</em>), some other objects may occupy the memory block that <code>p</code> points to. Thus, you will have illegal access to an object you are not supposed to control.</p>
<p>Hackers can somehow find a way to exploit that vulnerability. For example, if the &quot;some other objects&quot; are credential information (username, password, etc) or any other sensitive data, the hacker can retrieve/modify them via <code>p</code> (the invalid use-after-free pointer).</p>
<blockquote>
<p>One of many possible fixes is to assign <code>nullptr</code> to the pointer right after <code>delete</code>:</p>
</blockquote>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> p </span><span style="color:#179299;">= </span><span style="color:#8839ef;">new int</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ... use p
</span><span>    </span><span style="color:#8839ef;">delete</span><span> p</span><span style="color:#7c7f93;">;
</span><span>    p </span><span style="color:#179299;">= </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// nullptr assignment right after delete
</span><span>
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; *</span><span>p </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// vulnerability
</span><span style="color:#7c7f93;">}
</span></code></pre>
<hr />
<h2 id="int-a-n"><code>int a[n];</code></h2>
<h3 id="explanation">Explanation</h3>
<p>Dr. Tien provided a scenario where we would like an array with dynamic size. Some may have tried this:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>cin </span><span style="color:#179299;">&gt;&gt;</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#8839ef;">int</span><span> a</span><span style="color:#7c7f93;">[</span><span>n</span><span style="color:#7c7f93;">]; </span><span style="font-style:italic;color:#9ca0b0;">// declaration
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>Here's the catch: the above declaration only works for some compilers. If you use MSVC (which is used by Visual Studio), this won't work since <code>n</code> is not a constant. It is because the current C++ standard forbids such declaration.</p>
<p>The (textbook, not-really-good but allowed to use in CS162) C++ way to declare a dynamic array is by using <code>new</code>.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>cin </span><span style="color:#179299;">&gt;&gt;</span><span> n</span><span style="color:#7c7f93;">;
</span><span>
</span><span>    </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a </span><span style="color:#179299;">= </span><span style="color:#8839ef;">new int</span><span style="color:#7c7f93;">[</span><span>n</span><span style="color:#7c7f93;">];
</span><span>    </span><span style="color:#8839ef;">delete[]</span><span> a</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// DO NOT FORGET TO DEALLOCATE
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>Or, since RAII is introduced, we can have a lot of nice things in C++. The modern way is to use <code>std::vector</code> <strong>(but you are not allowed to use it for the course anyways, this is just an introduction)</strong>.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;vector&gt; </span><span style="font-style:italic;color:#9ca0b0;">// std::vector
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>cin </span><span style="color:#179299;">&gt;&gt;</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>vector</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">&gt; </span><span style="font-style:italic;color:#1e66f5;">a</span><span style="color:#7c7f93;">(</span><span>n</span><span style="color:#7c7f93;">);
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// a will deallocate itself, no need for manual control
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>Also, with the benefit of RAII, we can replace the raw pointer with smart pointers, a (very cool) feature of C++. However, it is still a pointer (just a smarter one) and we don't have the benefits of an actual <code>std::vector</code>.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;memory&gt; </span><span style="font-style:italic;color:#9ca0b0;">// std::unique_ptr, std::make_unique
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>cin </span><span style="color:#179299;">&gt;&gt;</span><span> n</span><span style="color:#7c7f93;">;
</span><span>
</span><span>    std</span><span style="color:#179299;">::</span><span>unique_ptr</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">[]&gt;</span><span> a </span><span style="color:#179299;">= </span><span>std</span><span style="color:#179299;">::</span><span style="font-style:italic;color:#1e66f5;">make_unique</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">[]&gt;(</span><span>n</span><span style="color:#7c7f93;">);
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// a will deallocate itself, no need for manual control
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>Or, if you feel adventurous/nostalgic/cool/dumb, you can even use the C way:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;cstdlib&gt; </span><span style="font-style:italic;color:#9ca0b0;">// the C++ version of stdlib.h
</span><span>                   </span><span style="font-style:italic;color:#9ca0b0;">// std::malloc
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    std</span><span style="color:#179299;">::</span><span>cin </span><span style="color:#179299;">&gt;&gt;</span><span> n</span><span style="color:#7c7f93;">;
</span><span>
</span><span>    </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">) </span><span>std</span><span style="color:#179299;">::</span><span style="font-style:italic;color:#1e66f5;">malloc</span><span style="color:#7c7f93;">(</span><span>n </span><span style="color:#179299;">* </span><span style="color:#8839ef;">sizeof</span><span style="color:#7c7f93;">(</span><span style="color:#179299;">*</span><span>a</span><span style="color:#7c7f93;">));
</span><span>    std</span><span style="color:#179299;">::</span><span style="font-style:italic;color:#1e66f5;">free</span><span style="color:#7c7f93;">(</span><span>a</span><span style="color:#7c7f93;">); </span><span style="font-style:italic;color:#9ca0b0;">// DO NOT FORGET TO DEALLOCATE
</span><span>                  </span><span style="font-style:italic;color:#9ca0b0;">// std::free is used to free the allocation
</span><span>                  </span><span style="font-style:italic;color:#9ca0b0;">// made by std::malloc, std::calloc...
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>You have to calculate manually how much memory you would like to allocate with <code>std::malloc</code>. For the keyword <code>new</code>, that value is calculated by the compiler.</p>
<h3 id="history">History</h3>
<blockquote>
<p>Variable-length arrays (VLA) were introduced in C99. <em>And boy was it a mistake</em>. A lot of problems arose (you can read the StackOverflow thread below for more), so the C++ committee decided not to integrate that into C++.</p>
</blockquote>
<p><a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">Why aren't variable-length arrays part of the C++ standard?</a></p>
<hr />
<h2 id="reinterpret-cast">Reinterpret-cast</h2>
<h3 id="pointer-disguise">Pointer disguise</h3>
<p>Addresses are just numbers. The value that a pointer holds is just a number. What if a clueless you decide to assign an address of a pointer of type A, to a pointer of type B?</p>
<p>You have to be explicit to do the following in C++:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">float</span><span style="color:#179299;">*</span><span> b</span><span style="color:#7c7f93;">;
</span><span>
</span><span>a </span><span style="color:#179299;">=</span><span> b</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// NOT ALLOWED IN C++
</span><span>       </span><span style="font-style:italic;color:#9ca0b0;">// (allowed in C but will raise a warning)
</span><span>
</span><span>a </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">)</span><span> b</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// OK
</span></code></pre>
<p>It is a mechanism to protect you from accidental <code>a = b</code>. If you want to do so, you have to explicitly do the cast: <code>a = (int*) b</code>.</p>
<blockquote>
<p>This is what the cast does: we disguise <code>b</code> as an <code>int*</code>, so <code>(int*) b</code> <em>looks like</em> it's an <code>int*</code>, pointing to an <code>int</code> variable (<em>while it's pointing to a <code>float</code>, real sussy wussy</em> ඞ*)*.
<br/><br/>
Then, we can do the assignment <code>a = (int*) b</code> because both sides have the type of <code>int*</code>.</p>
</blockquote>
<p>This kind of cast is called the reinterpret cast.</p>
<blockquote>
<p>In C++, there exists a keyword called <code>static_cast</code>. C-style cast is used to simplify writing in this blog and is not recommended in almost all cases.</p>
</blockquote>
<p>Or maybe think twice before doing any sort of cast.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// C++-style cast
</span><span style="color:#8839ef;">int</span><span> a </span><span style="color:#179299;">= </span><span style="color:#8839ef;">static_cast</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">&gt;(</span><span>b</span><span style="color:#7c7f93;">);
</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> pa </span><span style="color:#179299;">= </span><span style="color:#8839ef;">static_cast</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">&gt;(</span><span>pb</span><span style="color:#7c7f93;">);
</span></code></pre>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// C-style cast
</span><span style="color:#8839ef;">int</span><span> a </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">)</span><span> b</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> pa </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">)</span><span> pb</span><span style="color:#7c7f93;">;
</span></code></pre>
<h3 id="dereferencing-the-disguised-pointer">Dereferencing the disguised pointer</h3>
<p>This bears another question: what is the value of <code>*a</code>?</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">float</span><span style="color:#179299;">*</span><span> b</span><span style="color:#7c7f93;">;
</span><span>
</span><span>b </span><span style="color:#179299;">= </span><span style="color:#8839ef;">new float</span><span style="color:#7c7f93;">{</span><span style="color:#fe640b;">5</span><span style="color:#7c7f93;">}; </span><span style="font-style:italic;color:#9ca0b0;">// *b == 5
</span><span>a </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">)</span><span> b</span><span style="color:#7c7f93;">;
</span><span>
</span><span>std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; *</span><span>a </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// is *a == 5?
</span></code></pre>
<p>We let <code>*b = 5</code> and do the cast. The value of <code>*a</code>, however, is not <code>5</code>. Assuming both <code>int</code> and <code>float</code> have 4 bytes (which is correct for most modern systems nowadays), the output for the above code is <code>1084227584</code>. This appears to be a random value, but it is not.</p>
<blockquote>
<p>Fundamentally, <code>float</code> and <code>int</code> have different mechanisms to represent numbers. With the same bit representation, the value of a <code>float</code> is different than that of an <code>int</code> (that's all you need to know for now, I won't go into the details).</p>
</blockquote>
<p>The bit value of <code>5</code> as a <code>float</code> is <code>01000000 10100000 00000000 00000000</code>. The bit value of<code>1084227584</code> as an <code>int</code> is, well, also <code>01000000 10100000 00000000 00000000</code>.</p>
<blockquote>
<p>Now you see the effect of this cast, and why it is called &quot;reinterpret-cast&quot;. It takes the bit value of one type and uses it to represent the value of another. Due to the difference in how <code>float</code> and <code>int</code> represent a number, with the same bit value, we get (totally) different numbers.</p>
</blockquote>
<h3 id="what-else">What else?</h3>
<p><img src="https://jalsol.github.io/blog/cs162-notes/comment.png" alt="" loading="lazy" decoding="async" /></p>
<p>There are many things I would like to talk about.</p>
<ul>
<li>The real terminology for &quot;pointer disguise&quot;, as mentioned in the comment, is &quot;type punning&quot;. But <em>what the fuck</em> is this wording anyways?</li>
<li>The example we have been using so far, <code>float</code> and <code>int</code>, have the same size (the same number of bytes). To explain what happens if we use <code>long long</code> and <code>int</code> instead, I would have to teach stuff like endians (which will be covered on CS201).</li>
</ul>
<p><strong>The use of reinterpret-cast is quite rare. It is considered a tricky hack. Do not use it if you aren't sure what you are doing.</strong></p>
<p>One famous example is the <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=p8u_k2LIZyo">Fast Inverse Square Root</a>, implemented in Quake III. They needed to manipulate the bit representation of a <code>float</code> value, but it was (and still is) forbidden in C/C++, so they reinterpret-cast to an <code>int</code>.</p>
<p>There are safer ways to reinterpret-cast without using pointers.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// The better C way
</span><span>
</span><span style="color:#8839ef;">union </span><span>u_fi </span><span style="color:#7c7f93;">{
</span><span>    </span><span style="color:#8839ef;">float</span><span> f</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#8839ef;">int</span><span> i</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">};
</span><span>
</span><span>u_fi u</span><span style="color:#7c7f93;">;
</span><span>u</span><span style="color:#179299;">.</span><span>f </span><span style="color:#179299;">= </span><span style="color:#fe640b;">5</span><span style="color:#7c7f93;">;
</span><span>
</span><span>std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt;</span><span> u</span><span style="color:#179299;">.</span><span>i </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// prints 1084227584
</span></code></pre>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// standard C++ (since C++20)
</span><span>
</span><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;bit&gt; </span><span style="font-style:italic;color:#9ca0b0;">// std::bit_cast
</span><span>
</span><span style="color:#8839ef;">float</span><span> f </span><span style="color:#179299;">= </span><span style="color:#fe640b;">5</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">int</span><span> i </span><span style="color:#179299;">=</span><span> std</span><span style="color:#179299;">::</span><span>bit_cast</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">&gt;(</span><span>f</span><span style="color:#7c7f93;">);
</span><span>
</span><span>std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt;</span><span> i </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// prints 1084227584
</span></code></pre>
<p><a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=p8u_k2LIZyo">Fast Inverse Square Root — A Quake III Algorithm</a></p>
<hr />
<h2 id="int-a-b-c"><code>int* a, b, c;</code></h2>
<h3 id="what-the-fuck">What the fuck?</h3>
<p>This is one of the things that may confuse new people.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a</span><span style="color:#7c7f93;">,</span><span> b</span><span style="color:#7c7f93;">,</span><span> c</span><span style="color:#7c7f93;">;
</span></code></pre>
<p>With the declaration above, only <code>a</code> is a pointer. <code>b</code> and <code>c</code> are normal variables. Yes.</p>
<p>If you would like to declare all of them as pointers, do the following:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int </span><span style="color:#179299;">*</span><span>a</span><span style="color:#7c7f93;">, </span><span style="color:#179299;">*</span><span>b</span><span style="color:#7c7f93;">, </span><span style="color:#179299;">*</span><span>c</span><span style="color:#7c7f93;">;
</span></code></pre>
<h3 id="coding-convention-for-pointer-annotation">Coding convention for pointer annotation</h3>
<p>There have been many debates on different ways to annotate things. The pointer annotation is no exception.</p>
<p>Many people let the <code>*</code> be next to the type (<code>int* a</code>) because it can be understood that <code>int*</code> is a type. However, this kind of declaration leads to our aforementioned problem.</p>
<p><code>int *a</code> would solve that problem, but it would be difficult to, say, find all pointers of <code>int</code> in a file using a search tool.</p>
<p>It depends on you to choose what style to follow. I personally stick to the <code>int* a</code> one and avoid declaring multiple pointers on the same line. If I want many pointers, they will have to be declared on different lines. This is recommended when you program in C++.</p>
<blockquote>
<p>Stick to one pointer per declaration and always initialize variables and the source of confusion disappears.</p>
<ul>
<li>Bjarne Stroustrup (the creator of C++)</li>
</ul>
</blockquote>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> a</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> b</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span> c</span><span style="color:#7c7f93;">;
</span></code></pre>
<p>Another way to deal with this is to define a new type with aliasing. For modern C++, that can be done with the keyword <code>using</code> (and is the recommended way).  For C and older C++ versions (before C++11), <code>typedef</code> has to be used.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">using </span><span style="font-style:italic;color:#df8e1d;">int_ptr </span><span style="color:#179299;">= </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// The * sticks to the type
</span><span>
</span><span>int_ptr a</span><span style="color:#7c7f93;">,</span><span> b</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// both a and b are pointers of int
</span></code></pre>
<p>Or, use C++'s smart pointers (although they were born to solve a completely unrelated problem):</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;memory&gt; </span><span style="font-style:italic;color:#9ca0b0;">// std::unique_ptr, std::shared_ptr, std::weak_ptr
</span><span>
</span><span>std</span><span style="color:#179299;">::</span><span>unique_ptr</span><span style="color:#7c7f93;">&lt;</span><span style="color:#8839ef;">int</span><span style="color:#7c7f93;">&gt;</span><span> a</span><span style="color:#7c7f93;">,</span><span> b</span><span style="color:#7c7f93;">;
</span></code></pre>
<h3 id="why">Why?</h3>
<p><em>Disclaimer: I am not a C/C++ historian.</em></p>
<p>From what I have researched, it is history.</p>
<p>The <code>*</code> is <strong>the dereference operator at heart</strong>, and in C, it should be tied to the declarator <strong>since C emphasizes syntax</strong>.</p>
<blockquote>
<p><em>My speculation</em>:
To enable backward compatibility, C++ compilers have to be able to compile that as well. I suppose that is the problem that Dr. Tien talked about shortly after the first lecture of the second week of 22APCS2.</p>
</blockquote>
<p><strong>C++, however, emphasizes types</strong>. It focuses a lot more on types. That is why the <code>*</code> follows the type. Read <a rel="noopener" target="_blank" href="https://www.stroustrup.com/bs_faq2.html#whitespace">Bjarne Stroustrup's opinion</a> on this matter.</p>
<p>Obviously, there are a lot more reasons why C compilers decided to do that. But I'm not old and knowledgeable enough to talk about it.</p>
<p><a rel="noopener" target="_blank" href="https://www.stroustrup.com/bs_faq2.html#whitespace">Stroustrup: C++ Style and Technique FAQ</a></p>
<hr />
<h2 id="size-as-a-function-parameter">Size as a function parameter?</h2>
<h3 id="dr-tien-was-wrong">Dr. Tien was &quot;wrong&quot;</h3>
<p>Dr. Tien mentioned that to avoid the mismatch between the actual size of a string and the independent value, an independent value for a C-string size is not needed.</p>
<p><strong>However, in practice, it's the exact opposite.</strong> <strong>This is one of the most well-known vulnerabilities ever existed: buffer overflow.</strong></p>
<p>Here are some examples:<code>printf</code> and <code>scanf</code> are two popular functions used for reading and writing in C. They do not require a size, and they are vulnerable to the aforementioned attack.</p>
<blockquote>
<p>By passing a size, you are in control of how much of your data is being processed. Without a size, you may have to process data that your buffer cannot control, leading to the illegal access of other memory blocks. You cannot simply check if something is out-of-bound. Hackers can exploit this to modify data illegally.</p>
</blockquote>
<p>As an example, since C11, <code>scanf_s</code> is introduced. It requires a parameter that indicates the size of the output. The <code>_s</code> suffix stands for &quot;safe&quot;. It's not random that a &quot;safe&quot; version of a function requires a size value.</p>
<p><a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=7mKfWrNQcj0">Strings can get you hacked! (buffer overflows, strcpy, and gets)</a></p>
<h3 id="or-was-he">Or, was he?</h3>
<p>Also in the small discussion after the first lecture of the second week of 22APCS2, I mentioned this problem. He was (unsurprisingly) aware of that vulnerability. However, his intention was that it would be redundant if we move to <code>std::string</code>.</p>
<blockquote>
<p>At some point, we will not use C-string anymore and move on to the glorified <code>std::string</code>, the recommended way to use strings in C++.
<br/><br/>
It is a struct(<em>) that wraps around a dynamically allocated <code>char*</code> and some other variables (like the size variable). It also comes with helper functions that make life a lot easier and safer.
<br/><br/>
(**): It is actually a class. However, specifically in C++, there is no major difference between a struct and a class.</em></p>
</blockquote>
<p>Because <code>std::string</code> has an internal member that stores the size, you do not need another one. If you need to get the size, just get its value (via the <code>size()</code> function). There is no need to recalculate the length of the string by calling <code>strlen</code> every time, like with the C-string. Recalculation will only take place when the string updates its content.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">void </span><span style="font-style:italic;color:#1e66f5;">print_size</span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">const</span><span style="font-style:italic;color:#e64553;"> std</span><span style="color:#179299;">::</span><span style="font-style:italic;color:#e64553;">string</span><span style="color:#179299;">&amp;</span><span style="font-style:italic;color:#e64553;"> s </span><span style="font-style:italic;color:#9ca0b0;">/* no need for a separated size variable */</span><span style="color:#7c7f93;">) {
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt;</span><span> s</span><span style="color:#179299;">.</span><span style="font-style:italic;color:#1e66f5;">size</span><span style="color:#7c7f93;">() </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// pulls out the size variable,
</span><span>                                   </span><span style="font-style:italic;color:#9ca0b0;">// no recalculation
</span><span style="color:#7c7f93;">}
</span><span>
</span><span>std</span><span style="color:#179299;">::</span><span>string s </span><span style="color:#179299;">= </span><span style="color:#40a02b;">&quot;Hi.&quot;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// guaranteed to be null-terminated
</span><span style="font-style:italic;color:#1e66f5;">print_size</span><span style="color:#7c7f93;">(</span><span>s</span><span style="color:#7c7f93;">); </span><span style="font-style:italic;color:#9ca0b0;">// prints 3
</span></code></pre>
<p>(Please note that you are not allowed to use <code>std::string</code> on this course)</p>
<hr />
<h2 id="hungarian-notation">Hungarian notation</h2>
<p>Dr. Tien named the variable that points to the head of the linked list <code>pHead</code>.</p>
<p><img src="https://jalsol.github.io/blog/cs162-notes/penishe.png" alt="" loading="lazy" decoding="async" /></p>
<p>The way of naming variables like this is called the Hungarian notation.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span> iSize</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// int size
</span><span>std</span><span style="color:#179299;">::</span><span>string strName</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// string name
</span><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> pchArr</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// pointer char array
</span><span style="color:#8839ef;">float </span><span>fU</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// float u
</span></code></pre>
<p>Basically, they shorten the name of the type and make that the prefix of the variable name.</p>
<p>This naming convention is <strong><em>ancient</em>.</strong> **Back in the day, they didn't have advanced IDEs. C++ had, and still has, implicit conversion (<em>which is bullshit</em>, see the last example in the <code>nullptr/NULL/0</code> section), so it is used to show whether implicit conversion could happen.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">int</span><span> iSize</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">float </span><span>fU</span><span style="color:#7c7f93;">;
</span><span>
</span><span>iSize </span><span style="color:#179299;">= </span><span>fU</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// this compiles normally but causes the loss of data
</span><span>            </span><span style="font-style:italic;color:#9ca0b0;">// (the digits after the decimal points)
</span><span>            </span><span style="font-style:italic;color:#9ca0b0;">// noticing that i != f, the programmer can see implicit conversion
</span></code></pre>
<p>However, modern tools make this <strong>completely unnecessary</strong>. You can see the type of the variables just by hovering over them with modern IDEs, and the compiler does warn you about the loss of data by implicit conversion with the right configuration, like the flag <code>-Wconversion</code>.</p>
<p>If you change the type of <code>fU</code> to <code>int</code>, you will have to rename <code>fU</code> to <code>iU</code> in <strong>every single file</strong> that contains it. This may take a lot of time, and even with modern tools (Find-and-Replace, variable rename using LSP, etc), it still requires some effort.</p>
<p>For weakly typed languages (like Python and JS), this notation can still be useful, but I don't see anyone using it, to be honest.</p>
<blockquote>
<p>My opinion on naming conventions can be found in <a href="/blog/cs161-notes/#coding-styles">my CS161 notes</a> (specifically the &quot;Variable naming&quot; and the &quot;Coding styles&quot; section).</p>
</blockquote>
<p>You can read <a rel="noopener" target="_blank" href="https://www.stroustrup.com/bs_faq2.html#Hungarian">Bjarne Stroustrup's opinion on the Hungarian notation</a> as well.</p>
<hr />
<h2 id="showing-off">&quot;Showing off&quot;</h2>
<p><em><strong>Note: Some concepts go way beyond the scope of the course.</strong></em></p>
<p>TL;DR: Guy tried to show off, then ended up showing off his problems.</p>
<p><img src="https://jalsol.github.io/blog/cs162-notes/showoff.png" alt="" loading="lazy" decoding="async" /></p>
<p>The image above was taken from the class CLC06, during their CSC10002 lecture.</p>
<blockquote>
<p><em>The task was to fix a memory leak. A student (you probably know who) offered to do it. He added irrelevant stuff that did not help solve the problem. He managed to fix it anyways, but this exposed something I would like to talk about.</em></p>
</blockquote>
<h3 id="constructor">Constructor</h3>
<p><em>Note: You are not taught to use constructors in this course. You will learn more about this in CS202.</em></p>
<p>The constructor is a function that runs when an object is created.</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">struct </span><span style="font-style:italic;color:#df8e1d;">Node </span><span style="color:#7c7f93;">{
</span><span>    </span><span style="font-style:italic;color:#1e66f5;">Node</span><span style="color:#7c7f93;">() {
</span><span>        std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&quot;Created!&quot; </span><span style="color:#179299;">&lt;&lt;</span><span> std</span><span style="color:#179299;">::</span><span>endl</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#7c7f93;">}
</span><span style="color:#7c7f93;">};
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    Node a</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Creates a new variable of type Node,
</span><span>            </span><span style="font-style:italic;color:#9ca0b0;">// so this will call Node()
</span><span>            </span><span style="font-style:italic;color:#9ca0b0;">// -&gt; prints &quot;Created!&quot; and ends the line
</span><span style="color:#7c7f93;">}
</span></code></pre>
<blockquote>
<p>Usually, people use structs to gather various data into one type. They only hold data and don't represent object models, which is why you should never write functions <strong>inside</strong> them. Constructors are somewhat allowed, but their uses are very limited as well.</p>
</blockquote>
<h3 id="data-0xdeafbeaf"><code>data = 0xdeafbeaf</code>;</h3>
<blockquote>
<p><code>0xDEADBEEF</code> is a special magic value used for debugging, something to indicate an error that should not happen at all. It was used to crash the whole system if addressed.
<br/><br/>
From my personal experience, this value is rarely used nowadays.</p>
</blockquote>
<ul>
<li>This is ✨<em><strong>m i s s p e l l e d</strong></em>✨
<ul>
<li>It's actually <code>0xDEADBEEF</code> (spelled &quot;dead beef&quot;, not &quot;deaf beaf&quot;).</li>
</ul>
</li>
<li>It is <em><strong>misused</strong></em>
<ul>
<li>By definition, it is only used to denote whether a behavior should not happen.</li>
<li>I do not see why the default value for the data of a valid node should be assigned a value that represents an error.</li>
<li>I do not see why calling the constructor should be treated as an error.</li>
<li>If you do not want the constructor to be called, don't define it in the first place. You may consider disabling constructors altogether (I won't explain how to do this, wait until CS202 or do the research yourself).</li>
</ul>
</li>
</ul>
<p>By <del>showing off</del> trying to avoid &quot;safety issues&quot;, he showed off his issues of not understanding what he programmed.</p>
<h3 id="assignment-in-constructors">Assignment in constructors???</h3>
<p>From the <a rel="noopener" target="_blank" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c49-prefer-initialization-to-assignment-in-constructors">C++ Core Guidelines</a>, initialization should be used to initialize (ofc). Assignment may not represent the clear intention and may introduce a &quot;Use before set&quot; bug.</p>
<p>So, instead of</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#1e66f5;">Node</span><span style="color:#7c7f93;">() {
</span><span>    data </span><span style="color:#179299;">= </span><span style="color:#fe640b;">0</span><span style="color:#7c7f93;">;
</span><span>    next </span><span style="color:#179299;">= </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>do this instead</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#1e66f5;">Node</span><span style="color:#7c7f93;">() </span><span style="color:#179299;">: </span><span style="font-style:italic;color:#1e66f5;">data</span><span style="color:#7c7f93;">{}, </span><span style="font-style:italic;color:#1e66f5;">next</span><span style="color:#7c7f93;">{} {}
</span><span style="font-style:italic;color:#9ca0b0;">// Note that I don&#39;t write `data{0}`, because I might change the type of `data`
</span><span style="font-style:italic;color:#9ca0b0;">// to something else (e.g. std::string)
</span><span>
</span><span style="font-style:italic;color:#9ca0b0;">// If I let data be an int, data{} will assign 0 to `data`
</span><span>
</span><span style="font-style:italic;color:#9ca0b0;">// If I replace `int` with std::string, then `data{0}` will fail,
</span><span style="font-style:italic;color:#9ca0b0;">// but `data{}` will initialize an empty string
</span></code></pre>
<p>Or, in this specific case, also from the <a rel="noopener" target="_blank" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers">C++ Core Guidelines</a>, <strong>prefer in-class initializers to member initializers in constructors for constant initializers.</strong></p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">struct </span><span style="font-style:italic;color:#df8e1d;">Node </span><span style="color:#7c7f93;">{
</span><span>    </span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">data</span><span style="color:#7c7f93;">{};
</span><span>    Node</span><span style="color:#179299;">* </span><span style="font-style:italic;color:#1e66f5;">next</span><span style="color:#7c7f93;">{};
</span><span>
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// No need to implement Node()
</span><span style="color:#7c7f93;">};
</span></code></pre>
<p>You may read the guidelines for more information. It's short and straight to the point.</p>
<p><a rel="noopener" target="_blank" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c49-prefer-initialization-to-assignment-in-constructors">C++ Core Guidelines</a></p>
<h3 id="conclusion">Conclusion</h3>
<p>The code is not the most important part. Notice that I told you <strong>this code did not help to solve the original problem at all</strong>.</p>
<blockquote>
<p>Don't try to show off if you have no clue what you are doing.</p>
</blockquote>
<ul>
<li>
<p><em>Other interesting comments you'd probably like to see on the same guy</em></p>
<p><img src="https://jalsol.github.io/blog/cs162-notes/showoff1.png" alt="" loading="lazy" decoding="async" /></p>
<p><img src="https://jalsol.github.io/blog/cs162-notes/showoff2.png" alt="" loading="lazy" decoding="async" /></p>
<p><img src="https://jalsol.github.io/blog/cs162-notes/showoff3.png" alt="" loading="lazy" decoding="async" /></p>
</li>
</ul>
<hr />
<h2 id="the-arrow-operator"><code>-&gt;</code> (The arrow operator)</h2>
<h3 id="what-is-it">What is it?</h3>
<p>Suppose the following code:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">struct </span><span style="font-style:italic;color:#df8e1d;">Node </span><span style="color:#7c7f93;">{
</span><span>    </span><span style="color:#8839ef;">int</span><span> data</span><span style="color:#7c7f93;">;
</span><span>    Node</span><span style="color:#179299;">*</span><span> next</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">};
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    Node</span><span style="color:#179299;">*</span><span> ptr </span><span style="color:#179299;">= </span><span style="color:#8839ef;">new </span><span style="font-style:italic;color:#1e66f5;">Node</span><span style="color:#7c7f93;">{</span><span style="color:#fe640b;">5</span><span style="color:#7c7f93;">, </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">};
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt; *</span><span style="color:#7c7f93;">(</span><span>ptr</span><span style="color:#7c7f93;">)</span><span style="color:#179299;">.</span><span>data </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// prints 5
</span><span>    std</span><span style="color:#179299;">::</span><span>cout </span><span style="color:#179299;">&lt;&lt;</span><span>   ptr</span><span style="color:#179299;">-&gt;</span><span>data </span><span style="color:#179299;">&lt;&lt; </span><span style="color:#40a02b;">&#39;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&#39;</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// prints 5
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>As you can see, <code>*(ptr).data</code> and <code>ptr-&gt;data</code> are equivalent. <code>ptr-&gt;data</code> is much cleaner and you can think of its meaning as &quot;<code>ptr</code> points to the member data of the element&quot;.</p>
<p>This turns</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#179299;">*</span><span style="color:#7c7f93;">(</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">(</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">(</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">(</span><span>ptr</span><span style="color:#7c7f93;">)</span><span style="color:#179299;">.</span><span>next</span><span style="color:#7c7f93;">)</span><span style="color:#179299;">.</span><span>next</span><span style="color:#7c7f93;">)</span><span style="color:#179299;">.</span><span>next</span><span style="color:#7c7f93;">)</span><span style="color:#179299;">.</span><span>next
</span></code></pre>
<p>into</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>ptr</span><span style="color:#179299;">-&gt;</span><span>next</span><span style="color:#179299;">-&gt;</span><span>next</span><span style="color:#179299;">-&gt;</span><span>next</span><span style="color:#179299;">-&gt;</span><span>next
</span></code></pre>
<h3 id="the-white-spaces-around-it">The white spaces around it</h3>
<p>Man, you don't know how cringe I felt when they did</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>cur </span><span style="color:#179299;">-&gt; </span><span>next
</span></code></pre>
<p>Please. <strong>Do not</strong> do that. That is ugly. That screams unprofessionalism. </p>
<p><em>I was surprised to see people who I thought knew how to code do this (maybe they do code very well in other languages, but not C or C++).</em></p>
<p>The <code>.</code>, <code>::</code> and <code>-&gt;</code> have one thing in common: they are used to access something. It makes perfect sense that they also follow the same convention.</p>
<p>You don't do</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>A </span><span style="color:#179299;">. </span><span>B
</span></code></pre>
<p>or</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>A </span><span style="color:#179299;">::</span><span> B
</span></code></pre>
<p>so please, don't do</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>A </span><span style="color:#179299;">-&gt; </span><span>B
</span></code></pre>
<p>Make it right, don't add those spaces:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>A</span><span style="color:#179299;">-&gt;</span><span>B
</span></code></pre>
<hr />
<h2 id="char-x-alice"><code>char* x = &quot;Alice&quot;;</code></h2>
<h3 id="question">Question</h3>
<p>This came from a lab question that caught me off-guard.</p>
<p>The question is: what will be the output of the program?</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// main.c
</span><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;stdio.h&gt;
</span><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;string.h&gt;
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> i</span><span style="color:#7c7f93;">,</span><span> n</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> x </span><span style="color:#179299;">= </span><span style="color:#40a02b;">&quot;Alice&quot;</span><span style="color:#7c7f93;">;
</span><span>
</span><span>    n </span><span style="color:#179299;">= </span><span style="font-style:italic;color:#1e66f5;">strlen</span><span style="color:#7c7f93;">(</span><span>x</span><span style="color:#7c7f93;">);
</span><span>    </span><span style="color:#179299;">*</span><span>x </span><span style="color:#179299;">=</span><span> x</span><span style="color:#7c7f93;">[</span><span>n</span><span style="color:#7c7f93;">];
</span><span>
</span><span>    </span><span style="color:#8839ef;">for </span><span style="color:#7c7f93;">(</span><span>i </span><span style="color:#179299;">= </span><span style="color:#fe640b;">0</span><span style="color:#7c7f93;">;</span><span> i </span><span style="color:#179299;">&lt;=</span><span> n</span><span style="color:#7c7f93;">; </span><span style="color:#179299;">++</span><span>i</span><span style="color:#7c7f93;">) {
</span><span>        </span><span style="font-style:italic;color:#1e66f5;">printf</span><span style="color:#7c7f93;">(</span><span style="color:#40a02b;">&quot;%s &quot;</span><span style="color:#7c7f93;">,</span><span> x</span><span style="color:#7c7f93;">);
</span><span>        </span><span style="color:#179299;">++</span><span>x</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#7c7f93;">}
</span><span>
</span><span>    </span><span style="font-style:italic;color:#1e66f5;">printf</span><span style="color:#7c7f93;">(</span><span style="color:#40a02b;">&quot;</span><span style="color:#ea76cb;">\n</span><span style="color:#40a02b;">&quot;</span><span style="color:#7c7f93;">,</span><span> x</span><span style="color:#7c7f93;">);
</span><span style="color:#7c7f93;">}
</span></code></pre>
<ul>
<li>A. Alice</li>
<li>B. ecilA</li>
<li>C. Alice lice ice ce e</li>
<li>D. lice ice ce e</li>
</ul>
<h3 id="the-unexpected-answer">The unexpected answer</h3>
<p>The answer is that this program will crash, without printing anything.</p>
<p>The line that causes the crash is <code>*x = x[n];</code>. It is because <code>&quot;Alice&quot;</code> is actually a constant string.</p>
<h3 id="analysis">Analysis</h3>
<p><em>Note: I advise reading the TL;DR only if you don't want to read the overcomplicated analysis.</em></p>
<blockquote>
<p><strong>TL; DR:</strong>
<br/><br/>
In C++, the string literal (double-quoted string) is <code>const char[N]</code>. The pointer now points to a constant string, so you can't modify it.
<br/><br/>
In C, the string literal is <code>char[N]</code>. However, I was fooled. I found out the hard way that although it's a <code>char[N]</code> and not <code>const char[N]</code>, in this specific case, it belongs to the read-only data section of the program, which means it's also constant. It is specified in <a rel="noopener" target="_blank" href="https://c-faq.com/decl/strlitinit.html">this C FAQ</a>.</p>
</blockquote>
<h3 id="program-crash">Program crash</h3>
<p>At first, I assumed it would run normally. However, this program will cause a runtime error (it crashes). And it will print nothing.</p>
<p>The compiler I used was <code>gcc-11</code>, on an x86-64 Linux system.</p>
<p>The first thing I did was check for any illegal memory manipulation. By compiling with the flag <code>-fsanitize=address</code>, the address sanitizer returned this message:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>AddressSanitizer</span><span style="color:#179299;">:</span><span>DEADLYSIGNAL
</span><span style="color:#179299;">=================================================================
</span><span style="color:#179299;">==</span><span style="color:#fe640b;">36679</span><span style="color:#179299;">==</span><span>ERROR</span><span style="color:#179299;">:</span><span> AddressSanitizer</span><span style="color:#179299;">:</span><span> SEGV on unknown address </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">562da3a88020 </span><span style="color:#7c7f93;">(</span><span>pc </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">562da3a872cd</span><span> bp </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">7ffca6f863e0</span><span> sp </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">7ffca6f863d0</span><span> T0</span><span style="color:#7c7f93;">)
</span><span style="color:#179299;">==</span><span style="color:#fe640b;">36679</span><span style="color:#179299;">==</span><span>The signal is caused by a WRITE memory access</span><span style="color:#179299;">.
</span><span>    #0 0x562da3a872cd in </span><span style="font-style:italic;color:#1e66f5;">main </span><span style="color:#7c7f93;">(</span><span style="color:#179299;">/</span><span>tmp</span><span style="color:#179299;">/</span><span>main</span><span style="color:#179299;">+</span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">12cd</span><span style="color:#7c7f93;">)
</span><span>    #</span><span style="color:#fe640b;">1 </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">7f715227cd8f</span><span> in __libc_start_call_main ..</span><span style="color:#179299;">/</span><span>sysdeps</span><span style="color:#179299;">/</span><span>nptl</span><span style="color:#179299;">/</span><span>libc_start_call_main</span><span style="color:#179299;">.</span><span>h</span><span style="color:#179299;">:</span><span style="color:#fe640b;">58
</span><span>    #</span><span style="color:#fe640b;">2 </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">7f715227ce3f</span><span> in __libc_start_main_impl ..</span><span style="color:#179299;">/</span><span>csu</span><span style="color:#179299;">/</span><span>libc</span><span style="color:#179299;">-</span><span>start</span><span style="color:#179299;">.</span><span>c</span><span style="color:#179299;">:</span><span style="color:#fe640b;">392
</span><span>    #</span><span style="color:#fe640b;">3 </span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">562da3a87164</span><span> in </span><span style="font-style:italic;color:#1e66f5;">_start </span><span style="color:#7c7f93;">(</span><span style="color:#179299;">/</span><span>tmp</span><span style="color:#179299;">/</span><span>main</span><span style="color:#179299;">+</span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">1164</span><span style="color:#7c7f93;">)
</span><span>
</span><span>AddressSanitizer can </span><span style="color:#8839ef;">not</span><span> provide additional info</span><span style="color:#179299;">.
</span><span>SUMMARY</span><span style="color:#179299;">:</span><span> AddressSanitizer</span><span style="color:#179299;">: </span><span style="font-style:italic;color:#1e66f5;">SEGV </span><span style="color:#7c7f93;">(</span><span style="color:#179299;">/</span><span>tmp</span><span style="color:#179299;">/</span><span>main</span><span style="color:#179299;">+</span><span style="color:#7c7f93;">0x</span><span style="color:#fe640b;">12cd</span><span style="color:#7c7f93;">)</span><span> in main
</span><span style="color:#179299;">==</span><span style="color:#fe640b;">36679</span><span style="color:#179299;">==</span><span>ABORTING
</span></code></pre>
<p>After some debugging, it can be seen that the assignment <code>*x = x[n]</code> is the reason for the crash. More precisely, changing the value of <code>*x</code> crashed the program (hence <code>The signal is caused by a WRITE memory access</code>).</p>
<p>It was weird. I thought I should've been able to modify the string that way since string literals in C are not constant. Immediately, I suspected that the string was, however, constant.</p>
<p>I went to check inside the <code>.rodata</code> section, which is for read-only data. By disassembling the program with <code>objdump -d -j .rodata main</code>, this is the following output:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>main</span><span style="color:#179299;">:</span><span>     file format elf64</span><span style="color:#179299;">-</span><span>x86</span><span style="color:#179299;">-</span><span style="color:#fe640b;">64
</span><span>
</span><span>Disassembly of section </span><span style="color:#179299;">.</span><span>rodata</span><span style="color:#179299;">:
</span><span>
</span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">000000000002000 </span><span style="color:#179299;">&lt;</span><span>_IO_stdin_used</span><span style="color:#179299;">&gt;:
</span><span>    2000</span><span style="color:#179299;">:       </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">1 </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">0 </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">2 </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">0 41 6</span><span style="color:#8839ef;">c </span><span style="color:#fe640b;">69 63 65 </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">0 25 73 20 </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">0 0</span><span style="color:#8839ef;">a </span><span style="color:#7c7f93;">0</span><span style="color:#fe640b;">0     </span><span style="color:#179299;">....</span><span>Alice</span><span style="color:#179299;">.</span><span>%s </span><span style="color:#179299;">...
</span></code></pre>
<p>The first 4 bytes, <code>01 00 02 00</code>, are irrelevant to our problem. They represent the value of <code>_IO_stdin_used</code>. <a rel="noopener" target="_blank" href="https://reverseengineering.stackexchange.com/questions/19127/what-are-the-first-16-bytes-in-rodata-section">This is explained in this thread</a> and you can read more if interested (<em>note: user202729 a.k.a. <a rel="noopener" target="_blank" href="https://stats.ioinformatics.org/people/6997">Bui Hong Duc</a> appeared in that thread 😮</em>).</p>
<p>Then, here comes the strings that appear in the program:</p>
<ul>
<li><code>41 6c 69 63 65 00</code> is the hexadecimal representation of <code>&quot;Alice&quot;</code>.</li>
<li><code>25 73 20 00</code> is the hexadecimal representation of <code>&quot;%s &quot;</code>.</li>
<li><code>0a 00</code> is the hexadecimal representation of <code>&quot;\n&quot;</code>.</li>
<li>Note that each of them contains an extra byte <code>00</code>. That is the terminating null character <code>'\0'</code>.</li>
</ul>
<p>From that, it can be concluded that <code>&quot;Alice&quot;</code> is constant, because of its appearance in the <code>.rodata</code> section.</p>
<p>After some more research to find what the C standard has got to say about such behavior, I found <a rel="noopener" target="_blank" href="https://c-faq.com/decl/strlitinit.html">this C FAQ</a>. <em>Yes, I went all the way to disassemble the program, while this behavior is well documented.</em></p>
<p>To be more precise: <code>x</code> is not the string itself, it's just a pointer that happens to point to a constant string.</p>
<p>To modify the content of the string, replace:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> x </span><span style="color:#179299;">= </span><span style="color:#40a02b;">&quot;Alice&quot;</span><span style="color:#7c7f93;">;
</span></code></pre>
<p>with:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">char</span><span> str</span><span style="color:#7c7f93;">[] </span><span style="color:#179299;">= </span><span style="color:#40a02b;">&quot;Alice&quot;</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> x </span><span style="color:#179299;">=</span><span> str</span><span style="color:#7c7f93;">;
</span></code></pre>
<p>What this does is that it copies the content of <code>&quot;Alice&quot;</code> (the constant string) to another mutable string (which is <code>str</code> in this case). Now, you can modify <code>str</code> directly or via <code>x</code>.</p>
<p><em>Note: As for C++, it is explicitly stated that a string literal of size <code>N</code> has the type of <code>const char[N]</code>.</em></p>
<h3 id="the-result-after-fixing-the-crash">The result after fixing the crash</h3>
<p>Let's assume that the replacement mentioned is applied.</p>
<p>Then, <code>*x = x[n]</code> is basically assigning <code>x[0]</code> to <code>'\0'</code>. The string is <code>&quot;\0lice\0&quot;</code>.</p>
<p><code>printf</code> will print every character in the string until it encounters a <code>'\0'</code>.</p>
<ul>
<li>In the <code>for</code>-loop:
<ul>
<li>In the first iteration, it will print nothing.</li>
<li>In the next 4 iterations, it will print <code>lice</code>, then <code>ice</code>, then <code>ce</code>, then <code>e</code>.</li>
<li>In the last iteration, it will print nothing.</li>
</ul>
</li>
<li>In the final <code>printf</code> statement, <code>&quot;\n&quot;</code> does not have any format specifiers, hence it will just print a new line and <code>x</code> doesn't affect anything.</li>
</ul>
<p>→ The final output is <code>lice ice ce e</code> .</p>
<hr />
<h2 id="printf-c-c-ppp-ppp"><code>printf(&quot;%c %c &quot;, *++ppp, --*ppp);</code></h2>
<p>Also from a lab question, which I found interesting. I was not fooled this time.</p>
<h3 id="question-1">Question</h3>
<p>What will be the output of the following program?</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">#include </span><span style="color:#40a02b;">&lt;stdio.h&gt;
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">char</span><span> a</span><span style="color:#7c7f93;">[] </span><span style="color:#179299;">= </span><span style="color:#7c7f93;">{ </span><span style="color:#40a02b;">&#39;A&#39;</span><span style="color:#7c7f93;">, </span><span style="color:#40a02b;">&#39;B&#39;</span><span style="color:#7c7f93;">, </span><span style="color:#40a02b;">&#39;C&#39;</span><span style="color:#7c7f93;">, </span><span style="color:#40a02b;">&#39;D&#39; </span><span style="color:#7c7f93;">};
</span><span>    </span><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> ppp </span><span style="color:#179299;">= &amp;</span><span>a</span><span style="color:#7c7f93;">[</span><span style="color:#fe640b;">0</span><span style="color:#7c7f93;">];
</span><span>    </span><span style="color:#179299;">*</span><span>ppp</span><span style="color:#179299;">++</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Line 1
</span><span>    </span><span style="font-style:italic;color:#1e66f5;">printf</span><span style="color:#7c7f93;">(</span><span style="color:#40a02b;">&quot;%c %c &quot;</span><span style="color:#7c7f93;">, </span><span style="color:#179299;">*++</span><span>ppp</span><span style="color:#7c7f93;">, </span><span style="color:#179299;">--*</span><span>ppp</span><span style="color:#7c7f93;">); </span><span style="font-style:italic;color:#9ca0b0;">// Line 2
</span><span style="color:#7c7f93;">}
</span></code></pre>
<ul>
<li>A. <code>C B</code></li>
<li>B. <code>B A</code></li>
<li>C. <code>B C</code></li>
<li>D. <code>C A</code></li>
</ul>
<h3 id="analysis-1">Analysis</h3>
<p>Line 1 increases the pointer to the next address.</p>
<p>It is effectively the same as:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#179299;">*</span><span>ppp</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Dereference, but the value after that is unused so no effect at all
</span><span>ppp</span><span style="color:#179299;">++</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// Pointer increment
</span></code></pre>
<p>Line 2 causes <strong>undefined behavior</strong>.</p>
<p>From the <a rel="noopener" target="_blank" href="https://en.cppreference.com/w/c/language/eval_order">C documentation</a>:</p>
<blockquote>
<p><em>Order of evaluation of the operands of any C operator, including the order of evaluation of function arguments in a function-call expression, and the order of evaluation of the subexpressions within any expression is unspecified (except where noted below). The compiler will evaluate them in any order, and may choose another order when the same expression is evaluated again.</em>
<br/><br/>
<em>There is no concept of left-to-right or right-to-left evaluation in C, which is not to be confused with left-to-right and right-to-left associativity of operators: the expression <code>f1() + f2() + f3()</code> is parsed as <code>(f1() + f2()) + f3()</code> due to left-to-right associativity of operator+, but the function call to <code>f3</code> may be evaluated first, last, or between <code>f1()</code> or <code>f2()</code> at run time.</em></p>
</blockquote>
<p>This means that for the code in the question, there is no way to determine whether <code>*++ppp</code> or <code>--*ppp</code> will be executed first. This is implementation-defined, and the result may vary between different compilers.</p>
<ul>
<li>If <code>*++ppp</code> is executed first, then the output is <code>C B</code></li>
<li>If <code>--*ppp</code> is executed first, then the output is <code>C A</code></li>
</ul>
<hr />
<h2 id="const-int-p-vs-int-const-p"><code>const int* p</code> vs <code>int* const p</code></h2>
<p>This is another case of confusing notations.</p>
<h3 id="east-const-vs-west-const">East-const vs West-const</h3>
<p><code>const int a</code> is the same as <code>int const a</code>. There are terms to distinguish them, and there are even debates about them.</p>
<ul>
<li><code>const int a</code> is west-const (or, some people call it <strong>const-west</strong>)</li>
<li><code>int const a</code> is east-const</li>
</ul>
<p>West-const is more popular, due to the fact that it's human-friendly. Many people use it, I use it, too. However, human languages are <em>fucked</em>. They are inconsistent.</p>
<p>East-const is slowly getting more recognition, because it is more stable (which I will talk about in the next part).</p>
<p>Understanding east-const vs west-const is very important. However, I am not seeing west-const being replaced anytime soon, so I still use it.</p>
<h3 id="what-s-so-cool-about-east-const">What's so cool about east-const?</h3>
<p><img src="https://jalsol.github.io/blog/cs162-notes/east-west-const.png" alt="" loading="lazy" decoding="async" /></p>
<p>From <a rel="noopener" target="_blank" href="https://hackingcpp.com/cpp/design/east_vs_west_const.html">https://hackingcpp.com/cpp/design/east_vs_west_const.html</a></p>
<p>You can see the rule: <strong>What's left of const is constant.</strong></p>
<p>What does that mean?</p>
<p>Suppose we have <code>int const* const p</code>. Let's try to read it from right to left.</p>
<ul>
<li><code>... p</code> is a variable <code>p</code></li>
<li><code>... const p</code> is a variable <code>p</code>, which is a const</li>
<li><code>... * const p</code> is a variable <code>p</code>, which is a const pointer</li>
<li><code>... const* const p</code> is a variable <code>p</code>, which is a const pointer, which points to a const</li>
<li><code>int const* const p</code> is a variable <code>p</code>, which is a const pointer, which points to a const int</li>
</ul>
<p>You don't get such consistency with west-const, which causes the confusion in the first place.</p>
<h3 id="debunk-the-brain-fucker">Debunk the brain fucker</h3>
<p><em>The following will be very easy once you get the idea of east-const and west-const.</em></p>
<p>If you try to read from right to left, just like what we have just done:</p>
<ul>
<li><code>const int* p</code> is a <strong>normal pointer</strong> that points to a <strong>constant int</strong></li>
<li><code>int* const p</code> is a <strong>constant pointer</strong> that points to a <strong>normal int</strong></li>
</ul>
<p>You can also think of it this way (ofc they are not valid C/C++):</p>
<ul>
<li><code>const int* p</code> ⇒ <code>(const int)* p</code></li>
<li><code>int* const p</code> ⇒ <code>(int)* const p</code></li>
</ul>
<p>They are quite different:</p>
<table><thead><tr><th>const int* p</th><th>int* const p</th></tr></thead><tbody>
<tr><td>You can point to both const int and int</td><td>You can only point to int</td></tr>
<tr><td>You can change the value of p (e.g. you can point to const int a with p = &amp;a, then point to int b with p = &amp;b afterwards)</td><td>You can't change the value of p (e.g. if you declare int* const p = &amp;x then you can't do p = &amp;y afterwards)</td></tr>
</tbody></table>
<p>It's easy to mess things up. If you want to switch from east-const to west-const or vice versa, here is how you do it:</p>
<ul>
<li>
<p><code>const int* p</code> is west-const. The east-const version is <code>int const* p</code>.</p>
</li>
<li>
<p><code>int* const p</code> is east const. There is no direct west-const version. You may use type aliasing like this:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">using </span><span style="font-style:italic;color:#df8e1d;">int_ptr </span><span style="color:#179299;">= </span><span style="color:#8839ef;">int</span><span style="color:#179299;">*</span><span style="color:#7c7f93;">;
</span><span style="color:#8839ef;">const</span><span> int_ptr p</span><span style="color:#7c7f93;">; </span><span style="font-style:italic;color:#9ca0b0;">// const (int*) p
</span><span>                 </span><span style="font-style:italic;color:#9ca0b0;">// west-const again
</span></code></pre>
</li>
</ul>
<hr />
<h2 id="int-pop-exit-code-and-error-handling"><code>int pop()</code>, exit code, and error handling</h2>
<h3 id="he-do-a-little-trolling">he do a little trolling</h3>
<p>Dr. Tien threw all of us off guard with the prototype <code>int pop(Node*&amp; stack)</code>. A student returned the value at the top of the stack. If there is nothing inside the stack, then he would return -1 to report an error.</p>
<p>However, since the stack can contain any value it wants within the range of an <code>int</code> (including -1), this is not a nice way to handle error. What if the value of the stack top is -1? That is not an error, isn't it?</p>
<p>Dr. Tien actually wanted to return a <code>bool</code>. <code>1/true</code> if it can be popped, <code>0/false</code> otherwise.</p>
<p>To get the value of the top then pop it, you should split the task into a procedure of steps:</p>
<ul>
<li>is it empty?</li>
<li>Get the top</li>
<li>Pop the top</li>
</ul>
<h3 id="why-int-why-int-main">Why <code>int</code>? Why <code>int main()</code>?</h3>
<p>If our function only returns true or false, then <code>bool</code> should be enough to do the job, and not cause any unnecessary confusion.</p>
<p>In many cases, there are a lot more things to report, more than just either something is done successfully or not. This requires more than 2 values, and <code>bool</code> is simply not enough.</p>
<p>The term for this value is called &quot;exit code&quot; or &quot;status code&quot;.</p>
<p>Which value is used to represent which status, is defined by the programmers. There is usually no universal set of rules for that. Each company/organization has their own rules. However, there are some conventions that (almost) everyone uses:</p>
<ul>
<li>For desktop applications, <code>0</code> means the program exited successfully, <code>1</code> means the program exited failed, <code>255</code> (or <code>-1</code>) means out-of-bound error, etc.</li>
<li>For web applications, they follow <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">this convention of HTTP response status codes</a>.</li>
</ul>
<p>This explains a lot of things.</p>
<ul>
<li>Your program has to return an exit code, which is why <code>main()</code> has to be an <code>int</code> function, and not a <code>void</code> function by any means.</li>
<li>You often see <code>return 0;</code> at the end of <code>int main()</code>. This means that the program exited successfully. Nowadays, if you don't write that at the end, the compiler will do that job for you*.</li>
<li><code>404</code> is an HTTP response status code. It does indeed mean <code>Not found</code>, as you all know.</li>
</ul>
<p><em>(</em>): <code>int main()</code> is the only function that's implied to return 0 if there is no return statement. Other functions that are not <code>void</code> have to return something.*</p>
<h3 id="exceptions">Exceptions</h3>
<p><em>You will learn this in CS202. This is merely an introduction.</em></p>
<p>Another way to handle errors is to throw exceptions. To check whether an exception is thrown, try-catch is used.</p>
<p>This is kind of nice that you can keep the returning type of the function to be <code>void</code>, which may represent the intention of the function clearer. You also don't need to come up with a list of obscure numbers.</p>
<p>However, <a rel="noopener" target="_blank" href="https://stackoverflow.com/questions/2737328/why-should-i-not-wrap-every-block-in-try-catch">some consider the excessive use of try-catch to be a bad thing</a>.</p>
<hr />
<h2 id="return-value-or-function-argument">Return value or Function argument?</h2>
<p>Dr. Tien wanted to get the value of the top and pop it at the same time. He suggested 2 prototypes:</p>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// Return value
</span><span>
</span><span>Node</span><span style="color:#179299;">* </span><span style="font-style:italic;color:#1e66f5;">pop</span><span style="color:#7c7f93;">(</span><span style="font-style:italic;color:#e64553;">Node</span><span style="color:#179299;">*&amp; </span><span style="font-style:italic;color:#e64553;">stack</span><span style="color:#7c7f93;">) {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// returns a pointer to top
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span>
</span><span>    Node</span><span style="color:#179299;">*</span><span> top </span><span style="color:#179299;">= </span><span style="font-style:italic;color:#1e66f5;">pop</span><span style="color:#7c7f93;">(</span><span>stack</span><span style="color:#7c7f93;">);
</span><span>
</span><span>    </span><span style="color:#8839ef;">if </span><span style="color:#7c7f93;">(</span><span>top </span><span style="color:#179299;">== </span><span style="color:#d20f39;">nullptr</span><span style="color:#7c7f93;">) {
</span><span>        </span><span style="font-style:italic;color:#9ca0b0;">// empty stack
</span><span>    </span><span style="color:#7c7f93;">}
</span><span>
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span style="color:#7c7f93;">}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="font-style:italic;color:#9ca0b0;">// Function argument
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">pop</span><span style="color:#7c7f93;">(</span><span style="font-style:italic;color:#e64553;">Node</span><span style="color:#179299;">*&amp; </span><span style="font-style:italic;color:#e64553;">stack</span><span style="color:#7c7f93;">,</span><span style="font-style:italic;color:#e64553;"> Node</span><span style="color:#179299;">*&amp; </span><span style="font-style:italic;color:#e64553;">out</span><span style="color:#7c7f93;">) {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// modifies out, returns exit code
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span>
</span><span>    Node</span><span style="color:#179299;">*</span><span> top</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="color:#8839ef;">int</span><span> code </span><span style="color:#179299;">= </span><span style="font-style:italic;color:#1e66f5;">pop</span><span style="color:#7c7f93;">(</span><span>stack</span><span style="color:#7c7f93;">,</span><span> top</span><span style="color:#7c7f93;">);
</span><span>
</span><span>    </span><span style="color:#8839ef;">if </span><span style="color:#7c7f93;">(</span><span>code </span><span style="color:#179299;">== </span><span style="color:#fe640b;">0</span><span style="color:#7c7f93;">) {
</span><span>        </span><span style="font-style:italic;color:#9ca0b0;">// empty stack
</span><span>    </span><span style="color:#7c7f93;">}
</span><span>
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span style="color:#7c7f93;">}
</span></code></pre>
<p>There are advantages and disadvantages to both, but they are usually historical and very specific to certain cases.</p>
<h3 id="why-function-argument">Why function argument?</h3>
<ul>
<li>It allows the return of exit code.</li>
<li>You couldn't return the value of a big object back then, only things like <code>int</code>s and pointers.
<ul>
<li>If it could return a big object, it could cause a copy anyways.</li>
</ul>
</li>
<li>You can pass a stack-allocated variables (C++'s references do this under the hood):</li>
</ul>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">void </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">char</span><span style="color:#179299;">* </span><span style="font-style:italic;color:#e64553;">buffer</span><span style="color:#7c7f93;">, </span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#e64553;">size</span><span style="color:#7c7f93;">);
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// allocated on the stack
</span><span>    </span><span style="color:#8839ef;">char</span><span> buffer</span><span style="color:#7c7f93;">[</span><span style="color:#fe640b;">512</span><span style="color:#7c7f93;">];
</span><span>    </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span>buffer</span><span style="color:#7c7f93;">, </span><span style="color:#fe640b;">512</span><span style="color:#7c7f93;">);
</span><span>
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// no need to delete
</span><span style="color:#7c7f93;">}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">char</span><span style="color:#179299;">* </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#e64553;">size</span><span style="color:#7c7f93;">);
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// allocated on the heap
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// no explicit `new` keyword
</span><span>    </span><span style="color:#8839ef;">char</span><span style="color:#179299;">*</span><span> buffer </span><span style="color:#179299;">= </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#fe640b;">512</span><span style="color:#7c7f93;">);
</span><span>
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// no `new` but have to `delete`
</span><span>    </span><span style="color:#8839ef;">delete</span><span> buffer</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span></code></pre>
<h3 id="why-return-value">Why return value?</h3>
<p>This method is the modern C++ way to return multiple values.</p>
<ul>
<li>Instead of exit code, exceptions can be used.</li>
<li>Modern compilers can perform optimizations to avoid copy operations (e.g. copy elision).</li>
<li>Fewer parameters, in case there are so many things to return.</li>
<li>Avoid ambiguity in certain cases.</li>
</ul>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#8839ef;">struct </span><span style="font-style:italic;color:#df8e1d;">number_ranges </span><span style="color:#7c7f93;">{
</span><span>    </span><span style="color:#8839ef;">int</span><span> min</span><span style="color:#7c7f93;">,</span><span> max</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">};
</span><span>
</span><span>number_ranges </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span>
</span><span>    </span><span style="color:#8839ef;">return </span><span style="color:#7c7f93;">{</span><span>min</span><span style="color:#7c7f93;">,</span><span> max</span><span style="color:#7c7f93;">};
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// C++17 structured binding
</span><span>    </span><span style="color:#8839ef;">auto </span><span style="color:#7c7f93;">[</span><span>min</span><span style="color:#7c7f93;">,</span><span> max</span><span style="color:#7c7f93;">] </span><span style="color:#179299;">= </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">();
</span><span style="color:#7c7f93;">}
</span></code></pre>
<pre data-lang="cpp" style="background-color:#eff1f5;color:#4c4f69;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>
</span><span style="color:#8839ef;">void </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span style="color:#8839ef;">int</span><span style="color:#179299;">&amp; </span><span style="font-style:italic;color:#e64553;">out_min</span><span style="color:#7c7f93;">, </span><span style="color:#8839ef;">int</span><span style="color:#179299;">&amp; </span><span style="font-style:italic;color:#e64553;">out_max</span><span style="color:#7c7f93;">) {
</span><span>    </span><span style="font-style:italic;color:#9ca0b0;">// ...
</span><span>
</span><span>    out_min </span><span style="color:#179299;">=</span><span> min</span><span style="color:#7c7f93;">;
</span><span>    out_max </span><span style="color:#179299;">=</span><span> max</span><span style="color:#7c7f93;">;
</span><span style="color:#7c7f93;">}
</span><span>
</span><span style="color:#8839ef;">int </span><span style="font-style:italic;color:#1e66f5;">main</span><span style="color:#7c7f93;">() {
</span><span>    </span><span style="color:#8839ef;">int</span><span> min</span><span style="color:#7c7f93;">,</span><span> max</span><span style="color:#7c7f93;">;
</span><span>    </span><span style="font-style:italic;color:#1e66f5;">f</span><span style="color:#7c7f93;">(</span><span>min</span><span style="color:#7c7f93;">,</span><span> max</span><span style="color:#7c7f93;">);
</span><span style="color:#7c7f93;">}
</span></code></pre>
<hr />


            </main>
            <footer>
                
<p class="taxonomies">

</p>

                
            </footer>
        </div>
    </body>
</html>
        
